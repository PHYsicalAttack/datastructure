项目总结
-----------------------------
#### 网络层

网络中采用两种方式与服务器交互,一是http协议二是socket套接字,http只有登录/资源更新/其他SDK等东西中用到,游戏逻辑部分的网络通信
是完全是基于TCP的socket套接字,通信协议是类似ProtoBuff的协议,支持基本类型和BitVector32/BitArray,协议的收/发,编码/解码是在另一
个线程中进行的,对于客户端来说,消息收发各对应一个线程安全的消息队列,在逻辑更新的时候进行编/解码,收发工作,所以对客户端来说,网络交互
可以看成是单线程的.

用心跳包来维持服务器玩家在线状态.

#### 逻辑层

网络层收到消息后解码后,会将消息放到消息接受的队列里,当逻辑更新时,逻辑层的网关会按照消息Id派发到具体的某个模块中,交由逻辑进行处理
逻辑层实现的主要功能有:
	- 玩家数据模块
		包括玩家各个模块的逻辑数据,服务器数据同步,逻辑操作
	- 客户端计时器
		一个时间管理类,用SortDictory实现.用来管理需要延时或计时的回调.
	- 音频管理类
		一个基于抽象频道的,用于管理游戏背景,语音(互斥),音效的类
	- 其他一些插件杂项东西
		包括广告插件,安卓插件,快递查询,日志,屏蔽字之类的东西	

#### UI层
	UI层抽象成3层,由上到下依次是Windows(窗口) Frame(页面) Widget(组件)
	- Windows:表示一个大的功能入口,主要是提供了功能GameObject的创建方法
	- Frame:表示一个全屏的游戏界面,为了交给页面栈来管理,实现了便捷的显隐功能
	- Widget:可叠加在Frame上显示的组件,用法比较灵活
	
##### UI其他组件:
	- MessageBox: 用一个实例在各个功能界面中显示多种样式的提示框,能显示带弹出动画的奖励框,确定取消框,提示框等
	- FlyHint: 用一个实例在各个界面中显示飘字提示
	- LoopListView: 无限滚动的列表,使用插件实现,在聊天中的对话列表用这个实现的
	- Pageview: 无限滚动的界面,LoopListView的另一种表现,可以实现像微信表情界面那样的功能,也可以实现相册滑动那样的效果	
	- MutexGroup:互斥组,主要用于类似但每次只能显示一个界面显示,用于实现菜单栏的功能 
   	- FrameAnimation:简单的一个帧动画播放类
   	- FreeUsedList: 这不算是UI组件,这个类主要主要是对预设进行缓存,来实现回收与重复利用的功能

##### UI中动画实现的方法:
	- FrameAnimation: 用于简单的序列帧动画
	- Dotween: 大多数简单的动画
	- Animator: 复杂的界面动画

#### 游戏场景管理
	游戏在打包时只会将初始场景打入包体,其他场景都是被单独达成资源包来进行加载的
	场景切换有二种方式:
	1. 是在本场景中同步加载并显示加载场景并自动切换,正常情况下都是这种
	2. 是在本场景中异步加载其他场景,从引导场景到其他场景切换是这种方式

#### 游戏资源加载
	游戏资源的加载都是惰性(Lazy)加载的,这个类实现了iDispose接口,实际的AssetBundle只有在第一个加载资源时才从磁盘加载,然后通
	过引用计数管理,其他地方有引用时就计数加1,每次Dispose时,计数减1,当引用数为0时才卸载AssetBundle和加载自该资源包的所有资源

	资源加载的实现有同步和异步方式,目前基本上是同步加载的,实现了异步加载多个资源包的功能,但目前没用到,另外一个是实现了SpriteAtlas
	的资源包加载

#### 插件及SDK:
	- 高德地图安卓: 用于AR地图显示
	- Dotween: 游戏动画
	- OdinInspector: 游戏配置序列化,Serialize Anything.提供了许多强大且方便的Attribute.
	- LoopListView: 无限滚动的列表
	- Sqlite3: 游戏本地数据库
	- NewtonJson: C#数据与Json的序列化与反序列化
	- SharpZiblib: 剧情文本资源压缩
	- Live2d: 2版本,用于实现Live2d背景,如果再用的话建议接入3版本
	- QrCode: 用于扫描二维码
	- NSpeex: 游戏语音
	- 快递鸟SDK: 快递查询
	- UplTVSDK: 广告SDK
	- 爱贝SDK:测试付费


#### 与其他项目不同的地方
	游戏中大量使用了异步语法,游戏逻辑在初始化时除了玩家本身基本数据,玩家的功能模块数据都是未初始化的,需要异步去获取
	- 在网关中实现了消息的Awaiter,用于封装需要向服务器的同步的消息的回调
	- 在计时器中实现了DelayAwaiter封装延时回调,
	- 音频模块中使用了AcitonAwaiter来封装音频播放完成回调,
	- 在MessageBox中实现了MessageboxAwaiter封装按Messagebox按钮响应的回调,
	- UI中还有很多ActionAwaiter来封装通用的Action回调
	优点是:增加代码可读性,编写时的逻辑顺序比较顺畅
	缺点是:代码使用不当或理解不好会在UI存在大量的异步函数,并且出Bug的话比较难排查调试.
